{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","key","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"8LAGaA,G,KAAc,SAAC,GAAsB,EAApBC,cAAqB,IAAD,EAEVC,mBAAS,IAFC,+B,uBCArCC,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAEbC,EAFa,iDAEoCC,UAAWH,GAF/C,+DAGAI,MAAOF,GAHP,cAGbG,EAHa,gBAIIA,EAAKC,OAJT,uBAIXC,EAJW,EAIXA,KAEFC,EAAOD,EAAKE,KAAK,SAAAC,GAAQ,IAAD,EAC1B,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAVvB,kBAeZM,GAfY,4CAAH,sDCDPO,EAAc,SAAC,GAAoB,IAAlBH,EAAiB,EAAjBA,MAAOV,EAAU,EAAVA,IAEjC,OACI,yBAAKc,UAAU,0CACX,yBAAKC,IAAMf,EAAMgB,IAAMN,IACvB,+BAAMA,EAAN,OCFCO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,ECDb,SAAEA,GAAe,IAAD,EAEdF,mBAAS,CAC/BS,KAAM,GACNa,SAAS,IAJ2B,mBAEjCC,EAFiC,KAE1BC,EAF0B,KA2BxC,OApBAC,qBAAW,WAEPxB,EAASC,GACJwB,MAAM,SAAAC,GAEHH,EAAS,CACLf,KAAMkB,EACNL,SAAS,SAItB,CAACpB,IASGqB,EDV0BK,CAAc1B,GAAlCa,EAhBwB,EAgB7BN,KAAaa,EAhBgB,EAgBhBA,QAErB,OACI,oCACI,wBAAIJ,UAAU,qCAAd,IAAqDhB,EAArD,KAEEoB,GAAW,uBAAGJ,UAAU,oCAAb,WAEb,yBAAKA,UAAU,aAGPH,EAAOJ,KAAK,SAAAC,GAAG,OACX,kBAAC,EAAD,eACIiB,IAAMjB,EAAIC,IACLD,UE/BpBkB,EAAe,WAAO,IAAD,EAEM9B,mBAAS,CAAC,kBAFhB,mBAEvB+B,EAFuB,KAEXhC,EAFW,KAoB9B,OACI,oCACI,2EACA,kBAAC,EAAD,CAAaA,cAAgBA,IAC7B,6BAEA,4BAEQgC,EAAWpB,KAAK,SAAAT,GAAQ,OACpB,kBAAC,EAAD,CACI2B,IAAM3B,EACNA,SAAWA,U,MC5BvC8B,IAASC,OACP,kBAAC,EAAD,MACAC,SAASC,eAAe,U","file":"static/js/main.6a6f1bfa.chunk.js","sourcesContent":["import React, { useState } from 'react'\nimport PropTypes from 'prop-types';\n\nexport const AddCategory = ({ setCategories }) => {\n\n    const [inputValue, setInputValue] = useState(''); // //vacio es undefind\n\n    const handleInputChange = ( e ) => {\n        setInputValue( e.target.value );\n    }\n\n    const handleSubmit = (e) => {\n        e.preventDefault();\n\n        if ( inputValue.trim().length > 2 ) {\n            setCategories( cats => [ inputValue, ...cats, ] );\n            setInputValue('');\n        }\n\n    }\n\n    return (\n         //Cuando se envia un form este hace que la pagina se recargue por completo lo cual es malo porque react no recarga la pagina sino componentes, lo que se hace en este caso es quitar el evento de submit llamando la funcion handleSubmit\n       \n        <form onSubmit={ handleSubmit }>\n            <input \n                type=\"text\"\n                value={ inputValue }\n                onChange={ handleInputChange }\n            />\n        </form>\n    )\n}\n\n//Nombre del componentes, al setCategories lo hace obligatorio :)\n\nAddCategory.propTypes = {\n    setCategories: PropTypes.func.isRequired\n}\n","\n\n\nexport const getGifs = async( category ) => {\n\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=10&api_key=A8xMXqzieIHmtO3BjGLAtf1daSSDAv8K`;\n    const resp = await fetch( url );\n    const { data } = await resp.json();\n\n    const gifs = data.map( img => {\n        return {\n            id: img.id,\n            title: img.title,\n            url: img.images?.downsized_medium.url\n        }\n    })\n    //regersa un promesa de la coleccion de mis imagenes\n\n    return gifs;\n\n\n}","import React from 'react'\n\nexport const GifGridItem = ({ title, url }) => {\n\n    return (\n        <div className=\"card animate__animated animate__fadeIn\">\n            <img src={ url } alt={ title } />\n            <p> { title } </p>\n        </div>\n    )\n}\n","import React from 'react';\nimport { useFetchGifs } from '../hooks/useFetchGifs';\nimport { GifGridItem } from './GifGridItem';\n//import { getGifts } from \"../helpers/getGifts\";\n\nexport const GifGrid = ({ category }) => {\n /*MI ENTENDIMIENTO \n    Primero hacemos la peticion fetch con el async y el await, obnetemos los datos de la API y los filtramos para que solo traiga el id,title,url pero esto se saca de la data para despues ser mapeada y el array que te regresa se pone con la const gif la cual se va al setImages del hook y de ahi a la const de images para despues sacar sus propiedades  */\n/*   const [images, setImages] = useState([]);\n\n\n\n\n\n  //Este hook hace que no se vuelva a ejecutar la peticion porque tenemos un boton que agrega al contador un numero y por eso recarga el componente pero si usamos este hook la peticion solo se hara 1 vez\n  useEffect(() => {\n    //importamos el getGifts y como retorna una promesa usamos el then \n    getGifts(category).then(setImages)\n  }, [category]); */\n\n  //cambio de nombre\n    const { data:images, loading } = useFetchGifs( category );\n\n    return (\n        <>\n            <h3 className=\"animate__animated animate__fadeIn\"> { category } </h3>\n\n            { loading && <p className=\"animate__animated animate__flash\">Loading</p> }\n\n            <div className=\"card-grid\">\n                \n                {\n                    images.map( img => (\n                        <GifGridItem \n                            key={ img.id }\n                            { ...img }\n                        />\n                    ))\n                }\n            \n            </div>\n        </>\n    )\n}\n","import { useState, useEffect } from 'react'\nimport { getGifs } from '../helpers/getGifs';\n\n\nexport const useFetchGifs = ( category ) => {\n    \n    const [state, setState] = useState({\n        data: [],\n        loading: true\n    });\n\n    useEffect( () => {\n//los efectos no pueden ser async\n        getGifs( category )\n            .then( imgs => {\n                \n                setState({\n                    data: imgs,\n                    loading: false\n                });\n            })\n\n    }, [category])\n\n\n/* setTimeout(()=>{\n        setstate({ data:[1,2,3,4,5],\n            loading:false,\n        })\n    },3000) */\n\n    return state; // { data:[], loading: true };\n//regresa la data que es array y el loading en true\n\n}\n\n\n","import React, { useState } from 'react'\nimport { AddCategory } from './components/AddCategory';\nimport { GifGrid } from './components/GifGrid';\n\nexport const GifExpertApp = () => {\n    \n    const [categories, setCategories] = useState(['Akame Ga Kill']);\n /*  const categories=['samurai X','One punch','SAO']\n  const [categories, setcategories] = useState([\n    \"samurai X\",\n    \"One punch\",\n    \"SAO\",\n  ]);\n  const handleAdd = () => {\n      //Para agregar un valor al array no se usa el push porque se esta mutando el objeto pero esa es una mala practica, para eso  se usa el useState\n    //categories.push('Tokyo Ghoul')\n  \n    //Al usar el setcategories de esta forma se jode el estado del anterior porque crea uno nuevo\n\n    setcategories('Tokyo Ghoul')\n\n    //El set categories al ser un callback lo puedes manejar de esta forma\n    setcategories(cats=>[...cats,'Tokyo Ghoul'])\n}; */\n    return (\n        <>\n            <h2>App By BestoWaifu02 (Diego Robledo Mendoza)</h2>\n            <AddCategory setCategories={ setCategories } />\n            <hr />\n\n            <ol>\n                {\n                    categories.map( category  => (\n                        <GifGrid \n                            key={ category }\n                            category={ category }\n                        />\n                    ))\n                }\n            </ol>\n\n        </>\n    )\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { GifExpertApp } from './GifExpertApp';\n\nimport './index.css';\n\nReactDOM.render(\n  <GifExpertApp />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}